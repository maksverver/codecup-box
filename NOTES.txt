GAME NOTES

Game states have between 100 and 200 possible tile placements per turn, except
close to the beginning or end of the game. More than 260 seems rare in practice.

An upper bound is (16-2+1)*(20-6+1) + (16-6+1)*(20-2+1) == 434 based on grid
coordinates. (Actual upper limit?)

Number of turns per game seems closely centered around 30 including the first
neutral placement, so about 15 turns per player:

  turns percent
     26 3
     27 8
     28 23
     29 21
     30 21
     31 15
     32 7
     33 2

Theoretical upper limit: 39 turns, including the starting turn, so 19 per
player. Logic: there are 16*20 = 320 fields. The first tile covers 12 cells,
leaving 308 fields empty. Each next tile can overlap at most 4 cells (per the
rules) and thus covers at least 8 empty fields. 308 / 8 = 38.5, so at most 38
additional moves are possible. (Is this possible in practice?)


My current player is quite good at spoiling the opponent's squares, keeping
scores very low for both players.


FIRST MOVE TABLE

The player contains an opening book of first moves only (more is infeasiable due
to the random tiles causing a large number of possibly states after one move).

The state before the first move consists of three parts:

  1. the player's secret color
  2. the initial tile (always placed in the middle of the board)
  3. the given tile (to be placed by the player)

We can normalize the initial tile to 123456 and permute the given tile and secret
color accordingly, to reduce the state to just a pair of secret color and given tile.
This leads to 6 Ã— 6! = 4320 possible start states. We can calculate the best opening
move for each state.


REGENERATING THE FIRST MOVE TABLE

The first move table is stored in player/src/first-move-table.cc. For each possible
state it lists all the best moves (of which one is chosen at random, as usual), so
the total number of entries is larger than 4320 (about twice as large, currently,
due to symmetry).

Regenerate the table with something like:

% player/output/release/player --precompute-first-moves --deep >new-first-moves.txt

Use the options that give the best possible result while still running in a
reasonable time (e.g., if computing a move with --deep takes 3 seconds, then
calculating all first moves takes about 3 * 4320 / 3600 = 3.6 hours).

Copy/paste the contents of new-first-moves.txt to player/src/first-move-table.cc,
and edit it a bit to take less space (see existing format).

Edit player/src/first-move-table.h to update the number of entries too.


RELEASE INSTRUCTIONS

  1. `git status` # Make sure all changes are commited!
  2. `make clean`; `make -j4 all combined`
  3. Use arbiter.py to run a competition with the new and previous players
  4. Check player logs for unexpected warnings/errors.
  5. Submit to CodeCup.
  6. `git tag submission-#-id-#`
  7. Make a backup: `cp -r output/ backups/$(git rev-parse --short HEAD)`


AFTER THE COMPETITION

  - Download competition.csv and place in competition-results/
  - export SSL_CERT_FILE=tools/codecup.pem  # fix SSL certificate issue
  - tools/fetch-competition-playerlogs.sh test-X-competition-YYY 'Maks Verver'
  - tools/fetch-competition-transcripts.py tmp/cache/ \
      competition-results/test-X-competition-YYY.csv \
      competition-results/test-X-competition-YYY-transcripts.csv


RANDOM OBSERVATIONS / POSSIBLE LEADS

  - rect1 (b4dbbfb) is significantly faster than master (f7962b0) when running
    without --deep or --guess, despite the implementation being very similar. Why?
